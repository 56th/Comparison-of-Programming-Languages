\newgeometry{left=2cm,right=1cm,top=1cm,bottom=1cm,includefoot,heightrounded}

\section{Указания к выполнению работы}

Разработайте программу для решения поставленной задачи на языке \textbf{С++}, удовлетворяющую следующим требованиям:

\begin{enumerate}
	\item программа должна использовать для ввода-вывода потоки \textbf{STL},
	\item программа не должна содержать собственных реализаций стандартных алгоритмов и структур данных, а использовать существующие в \textbf{STL},
	\item размер каждой подпрограммы не должен превышать 10 строк.
\end{enumerate}

Протестируйте разработанную программу. Исследуйте асимптотические свойства разработанной программы на системе тестов с возрастающей размерностью.

Разработайте программы на языках \texttt{C\#} и \texttt{Java} с использованием аналогичных структур данных и сравните результаты работы.

(\url{http://dispace.edu.nstu.ru/didesk/course/show/5626/5})

\subsection{Вариант задания}

Задан большой текст (книга). Для наиболее часто встречающегося слова найти $N$ наиболее часто встречающихся пар слов.

\section{Размышления}
\label{analysis}

Для поиска наиболее популярного слова (или пары слов) удобно использовать контейнер \href{http://en.cppreference.com/w/cpp/container/map}{std::map} --- ассоциативный массив с красно-чёрным деревом под капюшоном. Ключ суть слово, значение --- частота.
(Аналоги в \texttt{Java} и \texttt{C\#} --- \texttt{TreeMap} и \texttt{SortedDictionary})

Через $n$ обозначим количество слов в нашей входной книжке. Тогда для занесения в контейнер данных потребуется $O(n \log m)$ времени (поиск в дереве осуществляется за логарифм), где $m \leq n$ --- количество слов без повторений. 

Положим $m = n$ (в такой книжке каждое слово уникально), чтобы проверить на практике логарифмическую сложность --- в действительности $m \ll n$ и алгоритм работает практически за линейное время.
Будем увеличивать длину книжки в 4 раза при начальном $n = 250 000$. Тогда отношение времени работы программы суть

\begin{equation}
\label{complexity}
	\frac{4n \log_2 4n}{n \log_2 n} = 4 \left( 1 + \frac{2}{\log_2 n} \right) \searrow 4, \: n \to \infty,
\end{equation}

то есть предполагается, что программа станет работать медленнее в 4+ раз, при этом при $n \to \infty$ отношение~(\ref{complexity}) должно становиться всё меньше и меньше.

\section{Тестирование}

\subsection{Тестирование на реальной книжке}

Для имплементации на всех языках результат один и тот же, во что и хотелось бы верить.

\begin{table}[H]
	\caption{“Martin Eden,” Jack London. Число слов --- 138 754}
	\label{table1}
	\begin{center}\begin{tabular}{|c|c|c|c|}
			\hline
			\textbf{частота} & \textbf{пара слов}\\
			\hline
			65 & martin eden\\
			44 & and martin\\
			42 & martin was\\
			40 & martin had\\
			27 & that martin\\
			25 & martin said\\
			20 & but martin\\
			19 & to martin\\
			18 & martin did\\
			18 & martin and\\
			17 & you martin\\
			13 & when martin\\
			13 & martin answered\\
			13 & as martin\\
			12 & martin went\\
			\hline
		\end{tabular}\end{center}
	\end{table}

\subsection{Тестирование сложности и проверка «размышлений»}

Результаты тестирования при $m = n$.

\begin{table}[H]
	\caption{C++}
	\label{tableC}
	\begin{center}\begin{tabular}{|c|c|c|c|}
			\hline
			$i$ & $n$ & $t$, сек & $t_i / t_{i-1}$\\
			\hline
			1 & 250 000 & .742 &  \\
			2 & 1 000 000 & 3.855 & 5.2 \\
			3 & 4 000 000 & 19.738 & 5.12 \\
			4 & 16 000 000 & 94.566 & 4.79\\
			\hline
	\end{tabular}\end{center}
\end{table}

\begin{table}[H]
	\caption{C\#}
	\label{tableSharpC}
	\begin{center}\begin{tabular}{|c|c|c|c|}
			\hline
			$i$ & $n$ & $t$, сек & $t_i / t_{i-1}$\\
			\hline
			1 & 250 000 & 5.01 & \\
			2 & 1 000 000 & 26.53 & 5.2 \\
			3 & 4 000 000 & 101.15 & 3.8 \\
			\hline
	\end{tabular}\end{center}
\end{table}

\begin{table}[H]
	\caption{Java}
	\label{tableJava}
	\begin{center}\begin{tabular}{|c|c|c|c|}
			\hline
			$i$ & $n$ & $t$, сек & $t_i / t_{i-1}$\\
			\hline
			1 & 250 000 & 5.32 & \\
			2 & 1 000 000 & 27.01 & 5.08 \\
			3 & 4 000 000 & 108.47 & 4.02 \\
			\hline
	\end{tabular}\end{center}
\end{table}

\section{Приложение}

Компилируем исходники с помощью MSVC:\\
\texttt{cl -EHsc -Ox testGen.cpp user.cpp},\\ 
генерируем тест из $n$ разных слов ($n$ подаётся на стандартный ввод):\\
\texttt{testGen > dummy.txt}\\
и наша программа готова к работе:\\
\texttt{user < dummy.txt >> out.txt}.

\subsection{testGen.cpp}

Генератор больших тестов --- общий для всех языков.
\lstinputlisting[language=C++]{../testGen.cpp}

\subsection{С++}
\textbf{user.cpp}
\lstinputlisting[language=C++]{../user.cpp}

\subsection{С\#}
\textbf{Program.cs}
\lstinputlisting[language=C]{../Program.cs}
\textbf{Analyzer.cs}
\lstinputlisting[language=C]{../Analyzer.cs}

\subsection{Java}
\textbf{Main.java}
\lstinputlisting[language=Java]{../Main.java}

\section{Делаем выводы}

Как видно из таблиц~(\ref{tableC} -- \ref{tableJava}), асимптотика, предсказанная в секции~(\ref{analysis}), работает всегда --- независимо от языка программирования (другого мы и не ожидали).

Так же стоит отметить, что \texttt{С++}, будучи языком компилируемым, справляется с задачей быстрее --- особенно это заметно на больших тестах (с тестом на 16 000 000 он расправился в 5 раз быстрее, чем \texttt{Java} и \texttt{C\#} справились с тестом в 4 раза меньшего размера).
Это можно объяснить тем, что \texttt{Java} и \texttt{C\#} --- языки с виртуальной машиной. Интерпретация байткода для машин в исполняемый код занимает своё время.
Этим же можно оправдать то, что оба языка показали себя примерно одинаково.

Было замечено, что в случае использования неупорядоченных ассоциативных контейнеров (хэш-таблиц), --- \texttt{std::unordered\_map} и \texttt{Dictionary} в \texttt{STL C++} и \texttt{С\#} соответственно, ---  на небольших тестах \texttt{C\#} обогнал \texttt{C++} приблизительно в 2 раза. Что наводит на мысль, что майкрософтовская реализация хэш-таблиц в \texttt{MSVC} для \texttt{STL} несколько хуже их же реализации для \texttt{C\#}. 
